# 开发规则（给 AI/开发者的统一约束）

本文档用于后续迭代时约束实现方式，确保：**UI 风格与 Dify 对齐、能复用的尽量复用、系统演进可控、自动触发与任务执行可靠**。当你把需求交给 AI 时，请同时附上本文档。

---

## 1. 总则（最高优先级）

1. **先复用再造轮子**：能在本仓库（Dify）找到“UI 组件/交互范式/通用逻辑/任务治理思路”的，优先复用或按同样模式实现。
2. **最小改动原则**：每次只做与当前需求直接相关的改动，不顺手重构、不清理无关代码。
3. **可追溯与可回滚**：重要设计必须落在文档与类型定义里；关键链路（运行/自动触发/产物）必须可追踪、可重试、可限制。
4. **单人自用 ≠ 随意写**：仍需幂等、防风暴、错误分层、日志与最小安全（密钥/OSS/本地 ComfyUI 地址不要泄漏到前端）。

---

## 2. UI/UX 规则（与 Dify 风格对齐）

### 2.1 风格基准

- 视觉：简洁、克制、偏产品化后台风格（中性色 + 少量强调色），避免“炫酷动效风”。
- 结构：左侧导航/资源区 + 中央画布 + 右侧配置面板（Drawer/Panel）是默认布局。
- 交互：面板配置即保存草稿；运行按钮明确；运行状态可见（进度/失败原因/重试）。

### 2.2 允许复用的 Dify 前端资产（优先从这里找）

当需要“按钮/弹窗/表单/图标/提示/布局/面板”等 UI 时，优先参考或复用：
- `web/app/components/base/`（基础组件与交互模式）
- `web/app/components/workflow/`、`web/app/components/workflow-app/`（与节点/运行态相关的 UI 思路）
- `web/themes/`、`web/app/styles/`（主题与样式习惯）
- `web/app/components/base/icons/`（图标体系与生成脚本）

> 规则：**先在上述目录里搜同类组件/交互，再决定新写**；如果新写，样式与 API 命名要与现有组件保持一致。

### 2.3 画布交互规范（自由画布）

- 节点：点击选中；双击/快捷键打开右侧配置面板；面板保存后节点外观有轻量提示（如“已更新”状态或小圆点）。
- 边（连线）：必须支持 `manual/auto` 切换；`auto` 状态有明显标识（例如边上 tag）。
- 输出节点自动生成：插入位置固定策略（右侧偏移 + 冲突下移）；必须支持撤销（Undo）。
- 运行反馈：节点上显示状态（queued/running/succeeded/failed/canceled）与进度；失败时有“查看详情/重试”。

---

## 3. 复用策略（从 Dify 借什么、不借什么）

### 3.1 强制复用/对齐的“思想与范式”

- **状态机**：运行态必须是显式状态机（不要散落布尔字段）。
- **事件流**：运行过程的进度/日志/产物必须通过事件（SSE/WS）推送，前端不可轮询堆接口。
- **可观测性**：每次运行必须有 `run_id/trace_id`，日志需带上下文（canvas_id/node_id）。
- **配置集中**：环境变量集中管理（参考 Dify `docker/.env.example` 的做法）。

### 3.2 允许直接复用的实现（按当前技术栈选择）

你后续可能出现两种实现路线，AI 必须按你当次指定的路线选用：

**A. 如果后端仍在本仓库的 Python/Celery 体系内做（不推荐但允许）**
- 优先复用 `api/tasks/`、`api/extensions/ext_celery.py` 的任务组织、队列划分、重试/超时处理方式。
- 复用 `docker/docker-compose.middleware.yaml` 的本地中间件启动方式。

**B. 如果按新项目 Node.js（Fastify + BullMQ）实现（推荐）**
- 不复制 Dify 的 Python 任务代码，但必须对齐其“任务治理习惯”：队列分组、可重试错误、幂等、防风暴、日志/trace。
- UI/交互仍以 Dify 前端为风格参考，组件优先借鉴 `web/app/components/base/`。

### 3.3 禁止直接搬运的内容

- 禁止把 Dify 的“平台型模块”整体搬过来：账号/租户/计费/插件市场/RAG/应用管理等。
- 禁止复制大段业务代码而不理解（必须先写出“为什么需要这段代码、它依赖什么、替代方案是什么”）。

---

## 4. 任务系统与自动触发规则（必须遵守）

### 4.1 运行（node_run）统一规范

- 每次点击运行/自动触发，必须创建一条 `node_run`，并写入：
  - `input_snapshot`（含 asset 引用）
  - `params_snapshot`（含 NodeType 版本）
  - `status`、`progress`、`error`
- 运行执行必须在 worker/队列中进行（除非是毫秒级纯计算）。

### 4.2 自动触发（auto edge）三条硬约束

1. **幂等键**：自动触发创建下游 run 必须使用 `idempotency_key` 防重复。
2. **环与风暴治理**：默认禁止形成环；若允许环必须配置 `max_hops` 与限速。
3. **多输入触发策略**：默认 `all_inputs_ready`，不默认 `each_new_asset`（除非明确需求）。

### 4.3 取消/重试原则

- 取消：是“尽力取消”，必须先标记状态再尝试取消远端任务，避免 UI 假死。
- 重试：必须可配置“重试是否复用输入快照”；重试不能绕过风暴限制。

---

## 5. 代码规范（TypeScript 优先）

- 必须使用 TypeScript，开启严格模式，禁止 `any`（确需使用要写原因与边界）。
- 业务逻辑必须有类型与输入校验（推荐 `zod`）。
- 错误必须结构化：`code`、`message`、`details`，前端可直接展示友好文案。
- 前端：组件分层（基础/业务），画布数据可序列化可迁移；表单 schema 驱动。
- 后端：API 有版本命名空间；任务可观测（run_id 贯穿 API/worker/日志）；产物上传必须由后端完成。

---

## 6. 测试与验证（自用也要有底线）

- 对“自动触发 + 幂等 + 环路限制 + 产物落库”写最小单测/集成测。
- 每次改动至少验证：手动运行成功；自动触发成功；失败可见且可重试。

---

## 7. AI 协作提示（每次提需求请附带）

1. 要做的功能（用户视角 3-5 条验收标准）
2. 涉及的节点类型与端口（输入/输出类型）
3. 是否需要自动触发、触发策略是什么
4. 产物类型（图片/视频）与 OSS 字段要求
5. 失败/重试/取消的期望行为

AI 输出必须包含：变更文件清单、新增/修改的数据结构、事件（SSE）新增项、风险与回滚方案。

