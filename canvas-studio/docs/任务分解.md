# 任务分解（Canvas Studio 后续开发清单）

> 优先级按 P0/P1/P2 标注，P0 先做；每个阶段尽量做成可演示的小闭环。

## 阶段 0：基础跑通（已完成 / 待确认）
- P0 ✅ monorepo 脚手架（web/api/worker + packages/shared/node-types）
- P0 ✅ Redis + BullMQ + SSE 链路打通（模拟任务）
- P0 ✅ Docker 仅容器化 API/Worker，Web 本地开发
- P0 ✅ 自动降级存储（SQLite 不可用时用 JSON 文件）

## 阶段 1：核心数据模型与 API
- P0 Canvas CRUD：完善 graph 结构（节点/端口/边的 schema 校验）与版本号
- P0 Run API：支持 run 详情查询、取消、重试；输出/错误结构化
- P1 事件流：SSE 聚合到 `GET /api/canvases/:id/events`（减少连接数）
- P1 资产 API：`GET /api/canvases/:id/assets`，返回缩略图/元信息
- P1 日志：run 事件增加日志类型与限流

## 阶段 2：节点类型与执行器
- P0 NodeType 注册：集中定义节点类型、端口、表单 schema（packages/node-types）
- P0 Demo 节点替换：将模拟节点改为通用“模板节点”可配置输出类型
- P1 ComfyUI 图片节点：模板化（workflow JSON + 参数映射），跑通上传 OSS
- P1 第三方图片 API 节点：HTTP executor，支持鉴权/重试/超时
- P2 ComfyUI 视频节点、第三方视频节点
- P2 资产节点：展示缩略图/播放，支持作为输入（edge 类型校验）

## 阶段 3：自动触发与治理
- P0 幂等键：按 canvasId+nodeId+输入资产+节点参数生成；自动触发必开
- P0 触发策略：`all_inputs_ready` / `each_new_asset`，边上配置
- P0 防环/防风暴：默认禁止环；允许环时需 max_hops + 速率限制
- P1 自动触发事件：`auto.triggered`，附带下游 runId
- P1 Run 状态机：补充 `failed` 的错误分类（可重试/不可重试）

## 阶段 4：前端画布与交互
- P0 画布持久化：保存/恢复 nodes/edges/viewport；版本冲突提示
- P0 运行态 UI：节点状态/进度/失败展示，SSE 订阅与断线重连
- P0 输出节点自动插入：布局策略 + 撤销
- P1 边配置面板：触发模式/策略、端口类型校验
- P1 右侧配置面板：节点表单 schema 渲染、即时保存
- P2 运行历史侧边栏：同节点多次运行记录查看

## 阶段 5：存储与运维
- P1 OSS 封装：统一上传、签名 URL、元数据（尺寸/时长/耗时/seed）
- P1 日志/可观测性：run_id/trace_id 贯穿，API/Worker 日志规范化
- P2 配置中心：.env 管理、不同环境的切换（本地/容器）

## 阶段 6：体验与安全
- P1 错误友好提示：前端 toast/面板展示，后端结构化错误码
- P2 权限与密钥管理：第三方 API/OSS 凭证加密存储（单人自用可简化）
- P2 导入/导出：画布 JSON 导出/导入（便于备份与迁移）

## 快速开发建议
- 每次提交前验证：手动运行成功；自动触发一跳成功；失败可见且可重试。
- 优先实现 ComfyUI 图片节点 + 自动触发链路（P0/P1），这是最具价值的最小闭环。

